üìù Checklist del proyecto Philosophers
1Ô∏è‚É£ Preparaci√≥n inicial

X Crear carpeta philo/ y abrirla en tu editor.

X Crear Makefile b√°sico (compilaci√≥n de todos los .c en objs/ y creaci√≥n del binario philo).

X Crear philo.h con:

XIncludes necesarios (stdlib.h, unistd.h, stdio.h, pthread.h, sys/time.h).

XPrototipos de funciones.

Definici√≥n de estructuras t_data y t_philo.

2Ô∏è‚É£ Recepci√≥n y validaci√≥n de argumentos

 Implementar parse_args.c.

 Comprobar n√∫mero de argumentos (4 o 5).

 Comprobar que todos son n√∫meros positivos.

 Guardar valores en t_data.

 Probar con entradas v√°lidas e inv√°lidas.

3Ô∏è‚É£ Inicializaci√≥n de estructuras y mutex

 Crear estructura t_philo:

ID del fil√≥sofo.

Puntero a t_data.

Contador de veces que ha comido.

Mutex de tenedor.

 Inicializar mutex de cada tenedor.

 Inicializar mutex para print / control de datos compartidos.

 Inicializar array de fil√≥sofos (t_philo[]) con datos correctos.

4Ô∏è‚É£ Funciones auxiliares (utils.c)

 ft_atoi para convertir strings a int.

 is_digit para validar n√∫meros positivos.

 Funci√≥n para obtener tiempo actual (get_time_ms).

 Funci√≥n de print segura (con mutex) para log de acciones.

5Ô∏è‚É£ Rutina de cada fil√≥sofo (routine.c)

 Crear funci√≥n que ser√° ejecutada por cada hilo.

 Implementar ciclo: pensar ‚Üí tomar tenedores ‚Üí comer ‚Üí soltar tenedores ‚Üí dormir.

 Actualizar contador de veces que ha comido.

 Marcar el tiempo de la √∫ltima comida.

6Ô∏è‚É£ Hilos y sincronizaci√≥n

 Crear hilos con pthread_create.

 Asegurar que todos los hilos usan correctamente los mutex.

 Implementar pthread_join para esperar que todos los hilos terminen.

 Prevenir deadlocks usando estrategia de ‚Äúfil√≥sofos pares/impresos primero‚Äù u otra que se indique en el subject.

7Ô∏è‚É£ Monitor / control de muerte

 Crear funci√≥n que verifica si alg√∫n fil√≥sofo ha muerto (sin comer a tiempo).

 Usar mutex para leer el estado de cada fil√≥sofo de forma segura.

 Detener la simulaci√≥n correctamente si alguien muere o todos han comido suficientes veces.

8Ô∏è‚É£ Pruebas finales

 Probar casos l√≠mite: 1 fil√≥sofo, 2 fil√≥sofos, 200 fil√≥sofos.

 Probar con y sin n√∫mero de comidas l√≠mite.

 Revisar que no haya memory leaks (valgrind).

 Revisar que no haya errores de compilaci√≥n ni warnings.